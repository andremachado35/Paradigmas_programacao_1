import java.util.*;
import java.io.*;

/**
 * ZooDeMamiferos é uma lista descritiva dos vários
 * mamíferos de um jardim zoológico, cujas classes
 * são SUBCLASSES de MAMÍFERO !!
 * 
 * 
 * @author FMM - PPIV
 * @version 1.0 (Abril 2005)
 */

public class ZooDeMamiferosList {

	
	
	// Em JAVA 1.5 o tipo ArrayList<? extends Mamifero> 
	// seria mais adequado para definir a estrutura de dados 
	// pretendida. Porém, num ArrayList<? extends Mamifero>
	// não é possível usar add() !!
	// Logo só poderá ser um tipo parâmetro !!
	
	// Vamos neste exemplo testar se o polimorfismo TYPE-SAFE 
	// é garantido em JAVA 1.5. Ou seja,
	// vamos testar se a definição mais rigorosa e estática de 
	// tipos de dados (note-se que em JAVA 1.4 todas as estrututas de 
	// dados eram parametrizadas por Object) oferecida em JAVA 1.5, 
	// que favorece o compilador, não faz perder a generalidade e
	// a extensibilidade que o "perigoso" "dynamic type checking" 
	// garantia.
	// Claro que se for garantido o polimorfismo (como de facto é !!)
	// e se ainda for adicionada COMPILE TYPE SAFETY temos que 
	// concluir que JAVA 1.5 melhorou !!
	// Melhorou na segurança de tipos. Depois iremos analisar se 
	// melhorou na EXECUÇÃO (a JAVA VM é a mesma, o byte code é o
	// mesmo. Apenas mudou o compilador que agora compila de forma
	// diferente.
	// O compilador faz as suas conversões de tipos para Object ...
	// Estudaremos mais tarde as questões operacionais. Agora vamos analisar
	// as questões conceptuais, ou seja, como se deve desenvolver software
	// em JAVA 1.5 usando os mecanismos oferecidos.
	
	// Variável de Instância 
	
	private ArrayList<Mamifero> zooList; 
	      
	/**
	 * Construtor básico
	 */	
	public ZooDeMamiferosList() { zooList = new ArrayList<Mamifero>(); }

    /**
     * Construtor que cria um ArrayList<? extends Mamifero> a
     * partir de uma Collection genérica do mesmo tipo.
     * Este construtor permite inserir no ArrayList<Mamifero>
     * uma qualquer instância de uma subclasse de Mamifero.
     */
	public ZooDeMamiferosList(Collection<? extends Mamifero> animais) {
	    zooList = new ArrayList<Mamifero>(animais);
	}
	
	/**
     * Construtor que cria um ArrayList<? extends Mamifero> a
     * partir de uma Collection genérica do mesmo tipo.
     * Este construtor permite inserir no ArrayList<Mamifero>
     * uma qualquer instância de uma subclasse de Mamifero.
     */
	public ZooDeMamiferosList(ArrayList<? extends Mamifero> animais) {
	    zooList = new ArrayList<Mamifero>(animais);
	}

			
	// Métodos de Instância

	/**
	 * Número de animais
	 */
	public int totalAnimais() { return zooList.size(); }
	
	/**
     * Inserir um Gato no zoo. É um método muito
     * específico. Serve apenas para teste. De facto,
     * num desenho polimórfico, o que se pretende é 
     * usar o supertipo, ou seja, fazer abstracção 
     * do tipo especifico. Polimorfismo é também abstracção.
     * Inserir uma instância de Gato no Zoo tem algum
     * sentido mas "abstrair" do tipo de Mamifero que
     * existe e inserir um Mamifero será sempre, do 
     * ponto de vista conceptual, o ideal.
     */
     public void insereGato(Gato mam) { 
         zooList.add(mam); 
     }

     /**
     * Inserir um Cão no zoo. É um método muito
     * específico. Serve apenas para teste, tal 
     * como se disse no método anterior.
     */
     public void insereCao(Cao mam) { 
         zooList.add(mam); 
     }
     
     /**
     * Genérico: Inserir um qualquer tipo de mamífero que 
     * seja de uma SUBCLASSE reconhecível pelo compilador 
     * da classe MAMÍFERO.
     * Este método faz com que os dois anteriores possam ser 
     * dispensados (e todos os outros N tipos possíveis).
     */
     public void insereMamifero(Mamifero mam) { 
        zooList.add(mam); 
     }

    /**
     * Inserir um qualquer outro mamífero que seja de uma
     * SUBCLASSE reconhecível pelo compilador da classe
     * MAMÍFERO.
     * SENDO TYPE_SAFE O COMPILADOR  NÃO CONFIA NO TIPO 
     * PARÂMETRO E, PELOS VISTOS, NÃO O CONSEGUE VERIFICAR.
     * ASSIM, O CÓDIGO SEGUINTE DÁ ERRO NO TIPO DO
     * PARÂMETRO !! 
     * Pessoalmente acho que ter por parâmetro <? extends Mamifero>
     * em vez de Mamifero traria muito mais clareza em termos de
     * TIPOS, mas tal não foi considerado. No entanto, repare-se no
     * método que a seguir se apresenta onde, por se tratar de
     * uma Collection<> já tudo se torna, estrahamente, natural !!
     */
     /* public void insereMamifero1(<? extends Mamifero> mam) { 
         zooList.add(mam); 
     }
     */
      
     /**
     * Inserir uma colecção de animais mamíferos a partir
     * de uma Collection de "unknown" types que "extends"
     * Mamifero. 
     */   
     public void insereAnimais(Collection<? extends Mamifero> mam) { 
         zooList.addAll(mam); 
     }
    
	/**
	 * Insere uma colecção de animais Mamiferos ou seja uma
	 * Collection de instâncias de subclasses de Mamifero.
	 * Qual a diferença para o método anterior? Qual usar a
	 * cada momento e porquê ?? SÂO EQUIVALENTES.
	 */
	 public void insereMamiferos(Collection<Mamifero> col) {
	    zooList.addAll(col); 
	}
	
	
	/**
	 * Devolve uma Collection de Mamiferos do zoo com peso 
	 * superior ao peso dado
	 */
	public Collection<Mamifero> pesoSupA(int peso) {
	   ArrayList<Mamifero> mamiferos = new ArrayList<Mamifero>();
	   for(Mamifero mamif: zooList) {
	       if(mamif.daPeso() > peso) mamiferos.add(mamif);
	    }
	    return mamiferos;
	}
	
	/**
	 * Devolve uma Collection de Mamiferos do zoo com nome 
	 * iniciado pela letra dada como parâmetro
	 */
	public Collection<Mamifero> nomeIniciadoPor(char letra) {
	   ArrayList<Mamifero> mamiferos = new ArrayList<Mamifero>();
	   for(Mamifero mamif: zooList) {
	       if(mamif.daNome().charAt(0) == letra) mamiferos.add(mamif);
	    }
	    return mamiferos;
	}

	   
	/**
	 * Lista com os nomes dos animais
	 */
	public ArrayList<String> nomes() {
	    ArrayList<String> nomes = new ArrayList<String>();
	    for(Mamifero mamif: zooList) {
	        nomes.add(mamif.daNome());
	    }
	    return nomes;
	}
	
	/**
	 * Verifica se nome do animal indicado existe
	 */
	public boolean existeNome(String nome) {
	    return (this.nomes().contains(nome));
    }
    
    /**
     * Dá o 1º Mamifero cujo nome começa pela letra
     * dada como parâmetro. Trata-se de um exemplo de
     * pesquisa.
     */
    public Mamifero animalDeNomeIniciadoPor(char letra) {
        Iterator it = zooList.iterator();
        Mamifero mamif = null;
        boolean encontrado = false;
        while(it.hasNext() && !encontrado) {
            mamif = (Mamifero) it.next();
	        if( mamif.daNome().charAt(0) == letra ) encontrado = true;
	    }
	    return mamif;
	 }
	
	/**
	 * toString()
	 */
	public String toString() {
	    StringBuffer s = new StringBuffer();
	    s.append("--------  JARDIM ZOOLÓGICO DE BRAGA ----------\n");
	    for(Mamifero mam : zooList) {
	        s.append(mam.toString());
	    }
	    return s.toString();
    }
    
    /**
     * Número de animais de dado tipo (CLASSE).
     */
    public int animaisPorTipo(String pack_tipo) {
        int conta = 0;
        for(Mamifero mamif : zooList) {
            if( (mamif.getClass().getName()).equals(pack_tipo) ) 
               conta++;
        }
        return conta;
   }
   
   /**
    * Escreve num ficheiro de texto as fichas de todos os 
    * animais do Jardim Zoológico.
    */
   public void gravaEmFichTxt(String fich) {
       try {
           FileWriter f = new FileWriter(fich);
           f.write(this.toString());
           f.flush(); f. close();
       }
       catch(IOException e) {};
    }
   
}
	
	
